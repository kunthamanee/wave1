<!doctype html>
<html lang="th">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Pixel Wave Defender ‚Äî Retro Sprites</title>
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
<style>
  :root{
    --bg:#071022; --panel:#0c2030; --accent:#ffd755; --accent2:#55ddff;
  }
  html,body{height:100%;margin:0;background:linear-gradient(180deg,#021026,#011018);
    font-family:"Press Start 2P", monospace;color:#fff}
  .wrap{display:flex;flex-direction:column;align-items:center;padding:12px;gap:8px;}
  canvas{background:linear-gradient(180deg,#01101a,#001018); image-rendering: pixelated;
    border:6px solid #07263a; box-shadow:0 8px 40px rgba(0,0,0,0.6); border-radius:10px;}
  .hud{display:flex;gap:12px;align-items:center;font-size:11px;text-shadow:0 0 6px rgba(0,0,0,0.6);}
  .hud .box{background:rgba(0,0,0,0.35);padding:8px 10px;border-radius:6px;border:2px solid rgba(255,255,255,0.03)}
  .controls{margin-top:8px;width:720px;max-width:96%;display:flex;gap:6px;justify-content:center;flex-wrap:wrap}
  .btn{background:linear-gradient(180deg,#ffd77f,#ffb84d);border:3px solid #4d2b00;padding:8px 10px;border-radius:6px;font-size:11px;cursor:pointer;box-shadow:0 6px 0 #8a5a0a;}
  .choiceBtn{background:linear-gradient(180deg,#6fe6ff,#38b0d7);color:#02121b;border:3px solid #05323b;padding:6px 8px;font-size:10px;border-radius:6px;box-shadow:0 6px 0 #034d57;}
  .choiceBtn.correct{background:linear-gradient(180deg,#9df59a,#51c65d);box-shadow:0 6px 0 #2b8a2f;}
  .choiceBtn.wrong{background:linear-gradient(180deg,#ff9aa0,#ff5968);box-shadow:0 6px 0 #8a2b3a;}
  .overlay{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);z-index:60;background:linear-gradient(180deg,#021825,#041833);padding:16px;border-radius:10px;width:92%;max-width:760px;border:4px solid rgba(255,255,255,0.03)}
  footer{font-size:10px;color:#89b;margin-top:8px}
  @media (max-width:520px){ .hud{font-size:9px} .btn{padding:6px 8px;font-size:10px} .choiceBtn{font-size:10px;padding:6px 8px} }
</style>
</head>
<body>
<div class="wrap">
  <div class="hud">
    <div class="box">SCORE: <span id="score">0</span></div>
    <div class="box">LIVES: <span id="lives">5</span></div>
    <div class="box">TIME LEFT: <span id="globalTimer">05:00</span></div>
    <div class="box">Q TIME: <span id="questionTimer">15</span>s</div>
    <div class="box">ENEMY: <span id="enemyName">‚Äî</span></div>
  </div>

  <canvas id="game" width="720" height="900"></canvas>

  <div class="controls" id="controls"></div>

  <div style="margin-top:6px">
    <button class="btn" id="startBtn">‚ñ∂Ô∏è START (5 ‡∏ô‡∏≤‡∏ó‡∏µ)</button>
    <button class="btn" id="pauseBtn">‚è∏Ô∏è PAUSE</button>
    <button class="btn" id="helpBtn">‚ùì HELP</button>
  </div>

  <footer>Pixel Retro ‚Ä¢ Œª = v/f (70%) ‚Ä¢ ‡∏ó‡∏§‡∏©‡∏é‡∏µ (30%) ‚Ä¢ 15s/‡∏Ç‡πâ‡∏≠ ‚Ä¢ 5 ‡∏ô‡∏≤‡∏ó‡∏µ</footer>
</div>

<div id="overlayRoot" style="position:fixed;left:0;top:0;right:0;bottom:0;display:none;align-items:center;justify-content:center;z-index:70"></div>

<script>
/* ---------- Audio helpers (WebAudio) ---------- */
let audioCtx = null;
function ensureAudio(){ if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }
function retroBeep(freq=880, time=0.08, type='square', vol=0.12){
  try{
    ensureAudio();
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = type; o.frequency.value = freq;
    g.gain.value = vol;
    o.connect(g); g.connect(audioCtx.destination);
    o.start();
    setTimeout(()=> o.stop(), time*1000);
  }catch(e){}
}
function retroBlast(time=0.25){
  try{
    ensureAudio();
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = 'sawtooth';
    o.frequency.value = 120;
    g.gain.value = 0.14;
    o.connect(g); g.connect(audioCtx.destination);
    o.start();
    const start = audioCtx.currentTime;
    g.gain.setValueAtTime(0.14, start);
    g.gain.exponentialRampToValueAtTime(0.001, start + time);
    o.frequency.exponentialRampToValueAtTime(40, start + time);
    setTimeout(()=> o.stop(), time*1000 + 20);
  }catch(e){}
}

/* ---------- Canvas & state ---------- */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const W = canvas.width, H = canvas.height;

let state = {
  running:false, score:0, lives:5, anim:0,
  currentEnemy:null, awaitingAnswer:false,
  globalTime:300, questionTime:15,
  correctCount:0, wrongCount:0, unansweredCount:0,
  encounteredQuestions:[], waves:[], particles:[]
};

/* ---------- Pixel-sprite drawing system ---------- */
/* We'll store sprites as small 2D arrays of color keys, then scale them up. */
const palette = {
  ' ': null,
  '1': '#0f2b44', // dark
  '2': '#55d6ff', // light cyan
  '3': '#ffd66b', // yellow
  '4': '#ff9e56', // orange
  '5': '#ffffff', // white
  '6': '#ff5d5d', // red
  '7': '#6bf5ff', // neon
  '8': '#b86bff', // purple
  '9': '#4bff9e', // green
  'A': '#05323b'  // dark accent
};

// Player sprite (24x24) ‚Äî NES-style rocket (array of strings, each char = color key)
const playerSprite = [
"   2222222   ",
"   2222222   ",
"    223322   ",
"    233332   ",
"   23333322  ",
"   23333322  ",
"   23333322  ",
"   23333322  ",
"  223333332  ",
"  2333333332 ",
"  2333353332 ",
"  2333333332 ",
"  2333333332 ",
"   23333332  ",
"    233332   ",
"    2A3A2    ",
"   2AAAAA2   ",
"   2A3A3A2   ",
"    2A3A2    ",
"     222     ",
"     222     ",
"     444     ",
"    44444    ",
"     44 4    "
];
// We'll treat '2' as cyan, '3' cyan-darker, '4' orange flame, '5' white, 'A' dark gray accent

// Several monster sprites in similar pixel style (12x12 or 16x16 small)
const monsterSprites = [
{ name:'Mini Squid', matrix:[
"  77777  ",
" 7777777 ",
"77 777 77",
"77 755 77",
"77 777 77",
" 7777777 ",
"  77777  ",
"   777   ",
"  9 9 9  ",
"  99999  ",
"   999   ",
"    9    "
], paletteMap:{'7':'#6bf5ff','5':'#05323b','9':'#4bff9e'} },
{ name:'Tentacle Buddy', matrix:[
"   777   ",
"  77777  ",
" 7777777 ",
"777733377",
"77 333 77",
"77 333 77",
"77777377 ",
" 777377  ",
"  7777   ",
"  9  9   ",
"  9999   ",
"   99    "
], paletteMap:{'7':'#6bf5ff','3':'#b86bff','9':'#4bff9e'} },
{ name:'Cyclops', matrix:[
"   6666  ",
"  666666 ",
" 66666666",
"66 555 66",
"66 555 66",
"66 555 66",
" 6666666 ",
"  66666  ",
"   666   ",
"  9 99 9 ",
"  99999  ",
"   999   "
], paletteMap:{'6':'#ff5d5d','5':'#ffffff','9':'#4bff9e'} },
{ name:'Piranha', matrix:[
"   8888  ",
"  888888 ",
" 88888888",
"88 333 88",
"88 333 88",
"88 333 88",
" 8888888 ",
"  88888  ",
"   888   ",
"  99 99  ",
"  99999  ",
"   999   "
], paletteMap:{'8':'#b86bff','3':'#05323b','9':'#4bff9e'} },
{ name:'Deep Leviathan (Boss)', matrix:[
"    666666    ",
"   66666666   ",
"  6666666666  ",
" 66 555555 66 ",
"66 5 5555 5 66",
"66 55555555 66",
"66 55555555 66",
" 66 555555 66 ",
"  6666666666  ",
"   66666666   ",
"    666666    ",
"     9999     "
], paletteMap:{'6':'#ff5d5d','5':'#ffffff','9':'#4bff9e'} }
];

// helper: draw a sprite (array of strings), top-left at (cx,cy) but centered on that point
function drawPixelSprite(matrix, cx, cy, scale=4, paletteOverride){
  const h = matrix.length;
  const w = matrix[0].length;
  const sx = Math.round(cx - (w*scale)/2);
  const sy = Math.round(cy - (h*scale)/2);
  for(let r=0;r<h;r++){
    const row = matrix[r];
    for(let c=0;c<w;c++){
      const key = row[c] || ' ';
      if(key === ' ') continue;
      const color = (paletteOverride && paletteOverride[key]) || (palette[key] || '#fff');
      ctx.fillStyle = color;
      ctx.fillRect(sx + c*scale, sy + r*scale, scale, scale);
    }
  }
}

/* ---------- Questions (70% calc / 30% theory) ---------- */
const easyF = [2,4,5,10,20];
const easyV = [40,50,100,200];
const theoryQ = [
  {q:'‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ñ‡∏µ‡πà (frequency) ‡∏´‡∏°‡∏≤‡∏¢‡∏ñ‡∏∂‡∏á‡∏≠‡∏∞‡πÑ‡∏£?', choices:['‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏Ç‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏™‡∏±‡πà‡∏ô‡∏ï‡πà‡∏≠‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ','‡∏£‡∏∞‡∏¢‡∏∞‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏¢‡∏≠‡∏î‡∏Ñ‡∏•‡∏∑‡πà‡∏ô‡∏™‡∏≠‡∏á‡∏¢‡∏≠‡∏î','‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏•‡∏∑‡πà‡∏ô','‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏•‡∏∑‡πà‡∏ô'], ans:0},
  {q:'‡∏Ñ‡∏ß‡∏≤‡∏°‡∏¢‡∏≤‡∏ß‡∏Ñ‡∏•‡∏∑‡πà‡∏ô (wavelength) ‡∏Ñ‡∏∑‡∏≠‡∏≠‡∏∞‡πÑ‡∏£?', choices:['‡∏£‡∏∞‡∏¢‡∏∞‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏à‡∏∏‡∏î‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡∏Å‡∏±‡∏ô‡∏ö‡∏ô‡∏Ñ‡∏•‡∏∑‡πà‡∏ô‡∏™‡∏≠‡∏á‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á','‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Å‡∏≤‡∏£‡∏™‡∏±‡πà‡∏ô‡∏ï‡πà‡∏≠‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ','‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏•‡∏∑‡πà‡∏ô','‡∏û‡∏•‡∏±‡∏á‡∏á‡∏≤‡∏ô‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏•‡∏∑‡πà‡∏ô'], ans:0},
  {q:'‡∏ñ‡πâ‡∏≤‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ñ‡∏µ‡πà‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ç‡∏∂‡πâ‡∏ô ‡πÇ‡∏î‡∏¢‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß‡∏Ñ‡∏á‡∏ó‡∏µ‡πà ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏¢‡∏≤‡∏ß‡∏Ñ‡∏•‡∏∑‡πà‡∏ô‡∏à‡∏∞?', choices:['‡∏™‡∏±‡πâ‡∏ô‡∏•‡∏á','‡∏¢‡∏≤‡∏ß‡∏Ç‡∏∂‡πâ‡∏ô','‡∏Ñ‡∏á‡πÄ‡∏î‡∏¥‡∏°','‡πÑ‡∏°‡πà‡∏™‡∏±‡∏°‡∏û‡∏±‡∏ô‡∏ò‡πå'], ans:0},
  {q:'‡∏Ñ‡∏•‡∏∑‡πà‡∏ô‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡πÄ‡∏õ‡πá‡∏ô‡∏Ñ‡∏•‡∏∑‡πà‡∏ô‡∏ä‡∏ô‡∏¥‡∏î‡πÉ‡∏î?', choices:['‡∏Ñ‡∏•‡∏∑‡πà‡∏ô‡∏ï‡∏≤‡∏°‡∏¢‡∏≤‡∏ß','‡∏Ñ‡∏•‡∏∑‡πà‡∏ô‡∏ï‡∏≤‡∏°‡∏Ç‡∏ß‡∏≤‡∏á','‡∏Ñ‡∏•‡∏∑‡πà‡∏ô‡∏ô‡∏¥‡πà‡∏á','‡∏Ñ‡∏•‡∏∑‡πà‡∏ô‡πÅ‡∏°‡πà‡πÄ‡∏´‡∏•‡πá‡∏Å‡πÑ‡∏ü‡∏ü‡πâ‡∏≤'], ans:0},
  {q:'‡πÅ‡∏≠‡∏°‡∏û‡∏•‡∏¥‡∏à‡∏π‡∏î (amplitude) ‡∏ö‡πà‡∏á‡∏ö‡∏≠‡∏Å‡∏≠‡∏∞‡πÑ‡∏£?', choices:['‡∏Ç‡∏ô‡∏≤‡∏î‡∏Å‡∏≤‡∏£‡πÄ‡∏Ñ‡∏•‡∏∑‡πà‡∏≠‡∏ô‡∏ó‡∏µ‡πà‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î‡∏à‡∏≤‡∏Å‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏™‡∏°‡∏î‡∏∏‡∏•','‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Ñ‡∏•‡∏∑‡πà‡∏ô‡∏ï‡πà‡∏≠‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ','‡∏£‡∏∞‡∏¢‡∏∞‡∏¢‡∏≠‡∏î‡∏Ñ‡∏•‡∏∑‡πà‡∏ô','‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏•‡∏∑‡πà‡∏ô'], ans:0}
];

function makeQuestion(enemy){
  // 70% calc
  if(Math.random() < 0.7){
    const f = easyF[Math.floor(Math.random()*easyF.length)];
    // choose v divisible by f
    const candidates = easyV.filter(v => v % f === 0);
    const v = candidates[Math.floor(Math.random()*candidates.length)];
    const lambda = v / f;
    const text = `‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì Œª = v / f\nv = ${v} m/s, f = ${f} Hz`;
    const choices = new Set([lambda]);
    while(choices.size < 4){
      // neighbour integers
      const delta = (Math.floor(Math.random()*5)-2); // -2..+2
      let w = lambda + delta;
      if(w <= 0) w = lambda + Math.abs(delta) + 1;
      choices.add(w);
    }
    const arr = shuffle(Array.from(choices));
    return {type:'calc', text, choices:arr, correct: lambda};
  } else {
    // theory
    const q = theoryQ[Math.floor(Math.random()*theoryQ.length)];
    const arr = shuffle(q.choices.slice());
    return {type:'theory', text:q.q, choices:arr, correctIndex: arr.indexOf(q.choices[q.ans])};
  }
}

/* ---------- Monster management ---------- */
function spawnMonster(){
  if(state.currentEnemy) return;
  // pick sprite (one of monsterSprites)
  const idx = Math.floor(Math.random()*monsterSprites.length);
  const m = monsterSprites[idx];
  const isBoss = m.name.includes('Boss') || m.matrix[0].length > 12;
  const enemy = {
    sprite: m.matrix,
    paletteMap: Object.assign({}, palette, m.paletteMap),
    x: W/2,
    y: 140,
    scale: isBoss ? 6 : 5,
    name: m.name,
    hp: isBoss ? 3 : 1,
    points: isBoss ? 200 : 80
  };
  state.currentEnemy = enemy;
  // prepare question
  const q = makeQuestion(enemy);
  state.currentQuestion = q;
  state.awaitingAnswer = true;
  state.questionTime = 15;
  state.encounteredQuestions.push({enemy: enemy.name, q});
  renderChoices(q, enemy);
  // small sound
  retroBeep(1000, 0.06, 'square', 0.06);
}

/* ---------- UI: render choices ---------- */
const controls = document.getElementById('controls');
function renderChoices(q, enemy){
  controls.innerHTML = '';
  const qb = document.createElement('div');
  qb.className = 'questionBox';
  qb.style.width = '100%';
  qb.style.whiteSpace = 'pre-wrap';
  qb.innerText = q.text;
  controls.appendChild(qb);
  for(let i=0;i<q.choices.length;i++){
    const ch = q.choices[i];
    const btn = document.createElement('button');
    btn.className = 'choiceBtn';
    btn.style.minWidth = '160px';
    btn.style.margin = '6px';
    btn.innerText = (q.type==='calc'? `Œª = ${ch} m` : ch);
    btn.onclick = ()=> onAnswer(q,ch,i,btn);
    controls.appendChild(btn);
  }
}

/* ---------- Answer handling ---------- */
function onAnswer(q, choice, idx, btnEl){
  if(!state.awaitingAnswer) return;
  state.awaitingAnswer = false;
  // disable buttons
  Array.from(document.querySelectorAll('.choiceBtn')).forEach(b=>b.disabled=true);
  let correct = false;
  if(q.type === 'calc'){ correct = (choice === q.correct); }
  else { correct = (idx === q.correctIndex); }
  if(correct){
    btnEl.classList.add('correct');
    state.score += state.currentEnemy.points;
    state.correctCount++;
    // fire wave (player centered)
    firePlayerWave(state.currentEnemy.x, state.currentEnemy.y);
    // enemy damaged
    state.currentEnemy.hp--;
    retroBeep(1200, 0.08, 'sawtooth', 0.09);
    if(state.currentEnemy.hp <= 0){
      // explosion
      createPixelExplosion(state.currentEnemy.x, state.currentEnemy.y, state.currentEnemy.paletteMap['9'] || '#4bff9e', 28);
      state.currentEnemy = null;
      setTimeout(()=>{ if(state.running) spawnMonster(); }, 700);
    } else {
      // still alive: small damage effect then continue
      createPixelExplosion(state.currentEnemy.x, state.currentEnemy.y, '#ff9e56', 12);
      setTimeout(()=>{ if(state.running) spawnMonster(); }, 900);
    }
  } else {
    btnEl.classList.add('wrong');
    state.wrongCount++;
    state.lives = Math.max(0, state.lives - 1);
    // player blink red
    blinkPlayer();
    retroBeep(220, 0.14, 'sine', 0.16);
    if(state.lives <= 0){ setTimeout(()=> endGame(), 400); return; }
    setTimeout(()=>{ state.currentEnemy = null; controls.innerHTML=''; if(state.running) spawnMonster(); }, 800);
  }
  updateHUD();
}

/* ---------- Player: static center ship, blink on damage ---------- */
let playerBlink = 0;
function blinkPlayer(){
  playerBlink = 8; // frames to blink
  createPixelExplosion(W/2, H-140, '#ff6b6b', 10);
}

/* ---------- Waves (laser) ---------- */
function firePlayerWave(tx, ty){
  const startX = W/2;
  const startY = H - 120;
  const dx = tx - startX, dy = ty - startY;
  const angle = Math.atan2(dy, dx);
  state.waves.push({ x:startX, y:startY, angle, speed:10, phase:0 });
  retroBeep(1800, 0.06, 'square', 0.08);
}

/* ---------- Particles (pixel explosion) ---------- */
function createPixelExplosion(x,y,color,count=18){
  for(let i=0;i<count;i++){
    state.particles.push({
      x, y,
      vx:(Math.random()-0.5)*6,
      vy:(Math.random()-0.5)*6,
      life:20 + Math.random()*30,
      color
    });
  }
  retroBlast(0.18);
}

/* ---------- HUD ---------- */
function updateHUD(){
  document.getElementById('score').textContent = state.score;
  document.getElementById('lives').textContent = state.lives;
  document.getElementById('enemyName').textContent = state.currentEnemy?state.currentEnemy.name:'‚Äî';
  const mm = String(Math.floor(state.globalTime/60)).padStart(2,'0');
  const ss = String(state.globalTime%60).padStart(2,'0');
  document.getElementById('globalTimer').textContent = `${mm}:${ss}`;
  document.getElementById('questionTimer').textContent = state.questionTime;
}

/* ---------- Render loop ---------- */
function render(){
  // background
  ctx.fillStyle = '#001022';
  ctx.fillRect(0,0,W,H);

  // starfield
  for(let i=0;i<120;i++){
    const sx = (i*37 + state.anim*2) % W;
    const sy = (i*53 + state.anim*3) % H;
    ctx.fillStyle = (i%9===0)?'#bfefff':'#11314a';
    ctx.fillRect(sx, sy, 1, 1);
  }

  // draw current enemy sprite (centered near top)
  if(state.currentEnemy){
    const e = state.currentEnemy;
    drawPixelSprite(e.sprite, e.x, e.y, e.scale, e.paletteMap);
  }

  // draw player centered at bottom
  // adjust blink visual
  const playerY = H - 110;
  const playerScale = 4;
  const spriteToDraw = playerSprite;
  // if blinking, temporarily override palette (red flash)
  if(playerBlink > 0){
    const override = Object.assign({}, palette, {'2':'#ff6b6b','3':'#ff6b6b','4':'#ff6b6b','A':'#330000'});
    drawPixelSprite(spriteToDraw, W/2, playerY, playerScale, override);
    playerBlink--;
  } else {
    drawPixelSprite(spriteToDraw, W/2, playerY, playerScale, palette);
  }

  // draw waves (laser beams)
  for(let i=state.waves.length-1;i>=0;i--){
    const w = state.waves[i];
    w.x += Math.cos(w.angle) * w.speed;
    w.y += Math.sin(w.angle) * w.speed;
    w.phase += 0.4;
    // trail
    ctx.strokeStyle = 'rgba(85,214,255,0.9)';
    ctx.lineWidth = 6;
    ctx.beginPath();
    ctx.moveTo(w.x - Math.cos(w.angle)*8, w.y - Math.sin(w.angle)*8);
    ctx.lineTo(w.x + Math.cos(w.angle)*8, w.y + Math.sin(w.angle)*8);
    ctx.stroke();
    // collision with enemy
    if(state.currentEnemy){
      const dx = w.x - state.currentEnemy.x;
      const dy = w.y - state.currentEnemy.y;
      const d = Math.sqrt(dx*dx + dy*dy);
      if(d < 30){
        // hit: damage handled elsewhere when answering correct; but also remove wave and create splash
        createPixelExplosion(state.currentEnemy.x, state.currentEnemy.y, '#ffffff', 8);
        state.waves.splice(i,1);
        continue;
      }
    }
    // remove if offscreen
    if(w.x < -50 || w.x > W+50 || w.y < -50 || w.y > H+50){
      state.waves.splice(i,1);
    }
  }

  // particles
  for(let i=state.particles.length-1;i>=0;i--){
    const p = state.particles[i];
    ctx.fillStyle = p.color;
    ctx.fillRect(p.x, p.y, 3, 3);
    p.x += p.vx;
    p.y += p.vy;
    p.vy += 0.12;
    p.vx *= 0.98; p.vy *= 0.98;
    p.life--;
    if(p.life <= 0) state.particles.splice(i,1);
  }

  // HUD text small inside canvas
  ctx.fillStyle = '#ffdba6';
  ctx.font = '10px "Press Start 2P"';
  ctx.textAlign = 'left';
  ctx.fillText('Œª = v / f', 12, 18);
  ctx.fillStyle = '#a6d8ff';
  ctx.textAlign = 'right';
  ctx.fillText('‡∏ï‡∏≠‡∏ö‡πÉ‡∏´‡πâ‡∏ó‡∏±‡∏ô 15s', W-12, 18);

  state.anim++;
}

/* ---------- Game loop & timers ---------- */
let mainLoopHandle = null;
function gameLoop(){
  if(!state.running) return;
  render();
  mainLoopHandle = requestAnimationFrame(gameLoop);
}

let tickHandle = null;
function startTimers(){
  if(tickHandle) clearInterval(tickHandle);
  tickHandle = setInterval(()=>{
    if(!state.running) return;
    // global timer
    state.globalTime--;
    // per-question timer
    if(state.awaitingAnswer){
      state.questionTime--;
      if(state.questionTime <= 0){
        // unanswered
        state.unansweredCount++;
        state.lives = Math.max(0, state.lives - 1);
        state.awaitingAnswer = false;
        // reveal miss effect
        blinkPlayer();
        createPixelExplosion(W/2, H-300, '#ff8a8a', 12);
        controls.innerHTML = '';
        state.currentEnemy = null;
        setTimeout(()=>{ if(state.running) spawnMonster(); }, 700);
      }
    }
    updateHUD();
    if(state.globalTime <= 0 || state.lives <= 0){
      endGame();
    }
  }, 1000);
}

/* ---------- Start / pause / end ---------- */
document.getElementById('startBtn').addEventListener('click', ()=>{
  if(!state.running) startGame();
  else { /* restart */ location.reload(); }
});
document.getElementById('pauseBtn').addEventListener('click', ()=>{
  state.running = !state.running;
  if(state.running){ startTimers(); gameLoop(); document.getElementById('pauseBtn').innerText='‚è∏Ô∏è PAUSE'; }
  else { if(tickHandle) clearInterval(tickHandle); if(mainLoopHandle) cancelAnimationFrame(mainLoopHandle); document.getElementById('pauseBtn').innerText='‚ñ∂Ô∏è RESUME'; }
});
document.getElementById('helpBtn').addEventListener('click', ()=> showHelp());

function startGame(){
  state.running = true;
  state.score = 0; state.lives = 5; state.globalTime = 300; state.questionTime = 15;
  state.correctCount = 0; state.wrongCount = 0; state.unansweredCount = 0;
  state.encounteredQuestions = []; state.waves = []; state.particles = []; state.currentEnemy = null;
  updateHUD();
  spawnMonster();
  startTimers();
  gameLoop();
  retroBeep(880, 0.07, 'square', 0.08);
  document.getElementById('startBtn').innerText = '‚Üª RESTART';
}

/* ---------- End game overlay ---------- */
function endGame(){
  state.running = false;
  if(tickHandle) clearInterval(tickHandle);
  if(mainLoopHandle) cancelAnimationFrame(mainLoopHandle);
  // overlay summary
  const overlay = document.createElement('div'); overlay.className = 'overlay';
  overlay.innerHTML = `
    <div style="text-align:center">
      <div style="font-size:18px;color:var(--accent)">üèÅ TIME'S UP / GAME OVER</div>
      <div style="color:#a6d8ff;margin-top:6px">‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô: ${state.score} &nbsp;|&nbsp; ‡∏ñ‡∏π‡∏Å: ${state.correctCount} &nbsp;|&nbsp; ‡∏ú‡∏¥‡∏î: ${state.wrongCount} &nbsp;|&nbsp; ‡πÑ‡∏°‡πà‡∏ï‡∏≠‡∏ö: ${state.unansweredCount}</div>
      <div style="background:#021827;padding:12px;border-radius:8px;margin-top:12px;color:#ffd;text-align:left;font-size:11px">
        <div style="font-weight:bold;color:#ffd07a">‡∏™‡∏£‡∏∏‡∏õ‡∏™‡∏±‡πâ‡∏ô ‡πÜ ‡πÄ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏Ñ‡∏•‡∏∑‡πà‡∏ô (‡∏°.5)</div>
        <div style="margin-top:6px">
          ‡∏™‡∏π‡∏ï‡∏£: <strong>Œª = v / f</strong><br>
          Œª = ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏¢‡∏≤‡∏ß‡∏Ñ‡∏•‡∏∑‡πà‡∏ô (m), v = ‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß‡∏Ñ‡∏•‡∏∑‡πà‡∏ô (m/s), f = ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ñ‡∏µ‡πà (Hz).<br>
          ‡∏ñ‡πâ‡∏≤‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ñ‡∏µ‡πà‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ç‡∏∂‡πâ‡∏ô (‡πÄ‡∏°‡∏∑‡πà‡∏≠ v ‡∏Ñ‡∏á‡∏ó‡∏µ‡πà) ‚Üí ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏¢‡∏≤‡∏ß‡∏Ñ‡∏•‡∏∑‡πà‡∏ô‡∏à‡∏∞‡∏™‡∏±‡πâ‡∏ô‡∏•‡∏á.
        </div>
        <div style="margin-top:8px;font-weight:bold;color:#a6d8ff">‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏°‡∏ó‡∏µ‡πà‡πÄ‡∏à‡∏≠</div>
        <ul style="color:#fff;font-size:12px;max-height:140px;overflow:auto;padding-left:18px">
          ${state.encounteredQuestions.slice(-8).map(it=>`<li><strong>${it.enemy}</strong>: ${escapeHtml(it.q.text).replace(/\n/g,' ')} </li>`).join('')}
        </ul>
      </div>
      <div style="margin-top:12px"><button class="btn" id="playAgain">‡πÄ‡∏•‡πà‡∏ô‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á</button></div>
    </div>
  `;
  const root = document.getElementById('overlayRoot'); root.style.display='flex'; root.innerHTML=''; root.appendChild(overlay);
  document.getElementById('playAgain').addEventListener('click', ()=> { root.style.display='none'; startGame(); });
}

/* ---------- Overlay helpers ---------- */
function showHelp(){
  const html = `
    <div style="padding:8px;color:#bcd">
      <div style="font-size:16px;color:var(--accent);text-align:center">‡∏ß‡∏¥‡∏ò‡∏µ‡πÄ‡∏•‡πà‡∏ô</div>
      <div style="margin-top:8px">‚Ä¢ ‡πÄ‡∏≠‡πÄ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÇ‡∏ú‡∏•‡πà‡∏°‡∏≤‡∏ó‡∏µ‡∏•‡∏∞‡∏ï‡∏±‡∏ß ‚Äî ‡∏Ñ‡∏∏‡∏ì‡∏°‡∏µ 15 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ‡∏ï‡∏≠‡∏ö‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏Ç‡πâ‡∏≠<br>‚Ä¢ ‡∏ï‡∏≠‡∏ö‡∏ñ‡∏π‡∏Å ‚Üí ‡∏¢‡∏≤‡∏ô‡∏à‡∏∞‡∏¢‡∏¥‡∏á‡πÄ‡∏•‡πÄ‡∏ã‡∏≠‡∏£‡πå‡∏ó‡∏≥‡∏•‡∏≤‡∏¢‡∏®‡∏±‡∏ï‡∏£‡∏π‡πÅ‡∏•‡∏∞‡πÑ‡∏î‡πâ‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô<br>‚Ä¢ ‡∏ï‡∏≠‡∏ö‡∏ú‡∏¥‡∏î‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà‡∏ï‡∏≠‡∏ö ‚Üí ‡πÄ‡∏™‡∏µ‡∏¢‡∏ä‡∏µ‡∏ß‡∏¥‡∏ï 1 ‡∏´‡∏ô‡πà‡∏ß‡∏¢<br>‚Ä¢ ‡πÄ‡∏ß‡∏•‡∏≤‡πÄ‡∏•‡πà‡∏ô‡∏£‡∏ß‡∏° 5 ‡∏ô‡∏≤‡∏ó‡∏µ</div>
      <div style="margin-top:10px;font-weight:bold">‡πÇ‡∏à‡∏ó‡∏¢‡πå: 70% ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì (Œª = v/f), 30% ‡∏ó‡∏§‡∏©‡∏é‡∏µ (‡∏°.5)</div>
      <div style="text-align:center;margin-top:12px"><button class="btn" id="closeHelp">‡∏õ‡∏¥‡∏î</button></div>
    </div>`;
  const root = document.getElementById('overlayRoot'); root.style.display='flex'; root.innerHTML = `<div class="overlay">${html}</div>`;
  document.getElementById('closeHelp').addEventListener('click', ()=> { root.style.display='none'; });
}

/* ---------- Utility ---------- */
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]] } return a; }
function escapeHtml(s){ return String(s).replace(/[&<>"']/g, m=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }

/* ---------- Init ---------- */
updateHUD();
render(); // initial draw

// first action: unlock audio on user gesture
window.addEventListener('pointerdown', ()=> { try{ ensureAudio(); }catch(e){} }, {once:true});

</script>
</body>
</html>
